/*
 * This file is part of Orbis, licensed under the GNU GPL v3 License.
 *
 * Copyright (C) 2024 Empire War
 * Copyright (C) contributors
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */
package org.empirewar.orbis.area;

import com.mojang.serialization.MapCodec;
import com.mojang.serialization.codecs.RecordCodecBuilder;

import org.empirewar.orbis.util.ExtraCodecs;
import org.empirewar.orbis.util.QuickHull3D;
import org.joml.Vector3d;
import org.joml.Vector3dc;
import org.joml.Vector3i;
import org.joml.Vector3ic;

import java.util.Arrays;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Set;

/**
 * Generated by AI, as I can't find any examples of polyhedral point testing, only 2D point in polygon stuff.
 */
public final class PolyhedralArea extends PolygonArea {

    public static MapCodec<PolyhedralArea> CODEC =
            RecordCodecBuilder.mapCodec(instance -> instance.group(ExtraCodecs.VEC_3I
                            .listOf()
                            .fieldOf("points")
                            .forGetter(c -> new LinkedList<>(c.points)))
                    .apply(instance, PolyhedralArea::new));

    private static final double EPSILON = 1e-7;

    private int[][][] edges, faces;

    public PolyhedralArea() {
        super();
    }

    private PolyhedralArea(List<Vector3ic> points) {
        super(points);
    }

    @Override
    protected void calculateEncompassingArea() {
        super.calculateEncompassingArea();
        try {
            this.edges = getPolyhedronEdges();
            this.faces = getPolyhedronFaces();
        } catch (IllegalArgumentException ignored) {
            // Means there were not enough points
        }
    }

    @Override
    public boolean contains(double x, double y, double z) {
        // Quick bounding box check first with a small epsilon for floating point errors
        if (x < min.x() - EPSILON
                || x > max.x() + EPSILON
                || y < min.y() - EPSILON
                || y > max.y() + EPSILON
                || z < min.z() - EPSILON
                || z > max.z() + EPSILON) {
            //            System.out.println(
            //                    String.format("Point (%.2f, %.2f, %.2f) is outside bounding box",
            // x, y, z));
            return false;
        }

        Vector3dc point = new Vector3d(x, y, z);
        //        System.out.println(String.format("\nTesting point: (%.2f, %.2f, %.2f)", x, y, z));

        // Check if point is exactly on a vertex
        for (Vector3ic vertex : points) {
            double dist = point.distanceSquared(vertex.x(), vertex.y(), vertex.z());
            if (dist < EPSILON * EPSILON) {
                //                System.out.println(String.format(
                //                        "Point is on vertex (%d, %d, %d), distance=%.6f",
                //                        vertex.x(), vertex.y(), vertex.z(), dist));
                return true; // Point is on a vertex
            }
        }

        // Check if point is on any edge
        //        System.out.println("Checking " + edges.length + " edges");
        for (int[][] edge : edges) {
            Vector3dc v1 = new Vector3d(edge[0][0], edge[0][1], edge[0][2]);
            Vector3dc v2 = new Vector3d(edge[1][0], edge[1][1], edge[1][2]);

            if (isPointOnEdge(point, v1, v2)) {
                //                System.out.println(String.format(
                //                        "Point is on edge between (%.2f, %.2f, %.2f) and (%.2f,
                // %.2f, %.2f)",
                //                        v1.x, v1.y, v1.z, v2.x, v2.y, v2.z));
                return true; // Point is on an edge
            }
        }

        // Use ray casting algorithm for point-in-polyhedron test
        // Cast a ray in a direction that's unlikely to be parallel to any face
        Vector3dc rayDir = new Vector3d(1, 0.5, 0.3).normalize();
        //        System.out.println("Using ray direction: " + rayDir);
        int intersections = 0;

        // Get all faces of the polyhedron
        //        System.out.println("Checking " + faces.length + " faces");

        for (int[][] face : faces) {
            // Convert face vertices to Vector3d
            Vector3d[] vertices = new Vector3d[face.length];
            for (int i = 0; i < face.length; i++) {
                vertices[i] = new Vector3d(face[i][0], face[i][1], face[i][2]);
            }

            // Check if point is on the face's plane
            if (isPointOnFace(point, vertices)) {
                //                System.out.println("Point is on face " + f);
                return true; // Point is on the face
            }

            // Check intersection with the face (as triangles)
            int faceIntersections = 0;
            for (int i = 1; i < face.length - 1; i++) {
                if (rayIntersectsTriangle(
                        point, rayDir, vertices[0], vertices[i], vertices[i + 1])) {
                    faceIntersections++;
                    //                    System.out.println(String.format(
                    //                            "  Intersection with triangle %d: (%.2f, %.2f,
                    // %.2f), (%.2f, %.2f, %.2f), (%.2f, %.2f, %.2f)",
                    //                            i,
                    //                            vertices[0].x,
                    //                            vertices[0].y,
                    //                            vertices[0].z,
                    //                            vertices[i].x,
                    //                            vertices[i].y,
                    //                            vertices[i].z,
                    //                            vertices[i + 1].x,
                    //                            vertices[i + 1].y,
                    //                            vertices[i + 1].z));
                }
            }
            intersections += faceIntersections;
            if (faceIntersections > 0) {
                //                System.out.println(String.format(
                //                        "Face %d: %d intersections (total: %d)",
                //                        f, faceIntersections, intersections));
            }
        }

        boolean isInside = (intersections % 2) == 1;
        //        System.out.println(String.format(
        //                "Total intersections: %d, point is %s",
        //                intersections, isInside ? "inside" : "outside"));
        return isInside;
    }

    /**
     * Returns the faces of the polyhedron by computing the convex hull of the points.
     * Each face is defined by its vertices in counter-clockwise order when viewed from outside.
     *
     * @return array of faces, where each face is an array of 3D points
     */
    private int[][][] getPolyhedronFaces() {
        if (points.size() < 4) {
            // Not enough points to form a 3D polyhedron
            return new int[0][][];
        }

        // Convert points to double array for QuickHull3D
        double[] coords = new double[points.size() * 3];
        int i = 0;
        for (Vector3ic point : points) {
            coords[i++] = point.x();
            coords[i++] = point.y();
            coords[i++] = point.z();
        }

        // Compute convex hull
        QuickHull3D hull = new QuickHull3D();
        hull.build(coords);

        // Get faces from convex hull
        int[][] faceIndices = hull.getFaces();
        int[][][] faces = new int[faceIndices.length][][];

        // Convert face indices to actual points
        final LinkedList<Vector3ic> pointsList = new LinkedList<>(points);
        for (int f = 0; f < faceIndices.length; f++) {
            int[] face = faceIndices[f];
            faces[f] = new int[face.length][3];
            for (int v = 0; v < face.length; v++) {
                Vector3ic point = pointsList.get(face[v]);
                faces[f][v][0] = point.x();
                faces[f][v][1] = point.y();
                faces[f][v][2] = point.z();
            }
        }

        return faces;
    }

    /**
     * Tests if a ray intersects a triangle using the Möller–Trumbore algorithm.
     *
     * @param rayOrigin The origin of the ray
     * @param rayDir The direction of the ray (must be normalized)
     * @param v0 First vertex of the triangle
     * @param v1 Second vertex of the triangle
     * @param v2 Third vertex of the triangle
     * @return true if the ray intersects the triangle, false otherwise
     */
    private boolean rayIntersectsTriangle(
            Vector3dc rayOrigin, Vector3dc rayDir, Vector3dc v0, Vector3dc v1, Vector3dc v2) {
        // Edge vectors
        Vector3d edge1 = new Vector3d();
        Vector3d edge2 = new Vector3d();

        // Calculate edge vectors
        v1.sub(v0, edge1);
        v2.sub(v0, edge2);

        // Calculate determinant
        Vector3d pvec = new Vector3d();
        rayDir.cross(edge2, pvec);
        double det = edge1.dot(pvec);

        // If determinant is near zero, ray is parallel to triangle plane
        if (Math.abs(det) < EPSILON) {
            return false;
        }

        double invDet = 1.0 / det;

        // Calculate distance from v0 to ray origin
        Vector3d tvec = new Vector3d(rayOrigin).sub(v0);

        // Calculate u parameter and test bounds
        double u = tvec.dot(pvec) * invDet;
        if (u < -EPSILON || u > 1.0 + EPSILON) {
            return false;
        }

        // Calculate v parameter and test bounds
        Vector3d qvec = new Vector3d();
        tvec.cross(edge1, qvec);
        double v = rayDir.dot(qvec) * invDet;
        if (v < -EPSILON || (u + v) > 1.0 + EPSILON) {
            return false;
        }

        // Calculate t, ray intersects triangle
        double t = edge2.dot(qvec) * invDet;

        // Check if the intersection is in front of the ray origin
        // We don't need an upper bound since we're checking for ray intersection, not line segment
        // intersection
        return t >= -EPSILON;
    }

    /**
     * Checks if a point lies on a face of the polyhedron.
     *
     * @param point The point to check
     * @param faceVertices The vertices of the face
     * @return true if the point is on the face, false otherwise
     */
    private boolean isPointOnFace(Vector3dc point, Vector3dc[] faceVertices) {
        if (faceVertices.length < 3) {
            return false;
        }

        // Calculate the face normal
        Vector3d v1 = new Vector3d(faceVertices[1]).sub(faceVertices[0]);
        Vector3d v2 = new Vector3d(faceVertices[2]).sub(faceVertices[0]);
        Vector3d normal = new Vector3d();
        v1.cross(v2, normal);

        // Check if point is on the plane of the face
        Vector3d p0 = new Vector3d(faceVertices[0]);
        Vector3d p = new Vector3d(point);
        p.sub(p0);
        double dist = Math.abs(p.dot(normal));

        if (dist > EPSILON) {
            return false; // Point is not on the plane
        }

        // Check if point is inside the face using ray casting in 2D
        // Project the face and point onto the most significant plane
        int coord1, coord2;
        double max = Math.max(Math.abs(normal.x), Math.max(Math.abs(normal.y), Math.abs(normal.z)));

        if (Math.abs(normal.x) == max) {
            coord1 = 1; // y
            coord2 = 2; // z
        } else if (Math.abs(normal.y) == max) {
            coord1 = 0; // x
            coord2 = 2; // z
        } else {
            coord1 = 0; // x
            coord2 = 1; // y
        }

        // Count intersections
        int n = faceVertices.length;
        boolean inside = false;

        for (int i = 0, j = n - 1; i < n; j = i++) {
            double[] vj = {faceVertices[j].x(), faceVertices[j].y(), faceVertices[j].z()};
            double[] vi = {faceVertices[i].x(), faceVertices[i].y(), faceVertices[i].z()};

            double x1 = vj[coord1];
            double y1 = vj[coord2];
            double x2 = vi[coord1];
            double y2 = vi[coord2];

            double px = point.get(coord1);
            double py = point.get(coord2);

            // Check if point is on the edge
            if (isPointOnEdge(px, py, x1, y1, x2, y2)) {
                return true;
            }

            // Check for intersection with the edge
            if (((y1 > py) != (y2 > py)) && (px < (x2 - x1) * (py - y1) / (y2 - y1) + x1)) {
                inside = !inside;
            }
        }

        return inside;
    }

    /**
     * Checks if a point is on an edge between two points.
     */
    private boolean isPointOnEdge(
            double px, double py, double x1, double y1, double x2, double y2) {
        // If the point is not within the bounding box of the edge, it's not on the edge
        if (px < Math.min(x1, x2) - EPSILON
                || px > Math.max(x1, x2) + EPSILON
                || py < Math.min(y1, y2) - EPSILON
                || py > Math.max(y1, y2) + EPSILON) {
            return false;
        }

        // Check if the point is on the line defined by the edge
        double cross = (y2 - y1) * (px - x1) - (x2 - x1) * (py - y1);
        return Math.abs(cross) < EPSILON;
    }

    /**
     * Gets all edges of the polyhedron.
     *
     * @return Array of edges, where each edge is represented by two points
     */
    private int[][][] getPolyhedronEdges() {
        Set<Edge> edgeSet = new HashSet<>();
        int[][][] faces = getPolyhedronFaces();

        // Extract edges from all faces
        for (int[][] face : faces) {
            for (int i = 0; i < face.length; i++) {
                int[] v1 = face[i];
                int[] v2 = face[(i + 1) % face.length];

                // Create a normalized edge (smaller index first to avoid duplicates)
                Edge edge = new Edge(v1, v2);
                edgeSet.add(edge);
            }
        }

        // Convert to array format
        int[][][] edges = new int[edgeSet.size()][2][3];
        int i = 0;
        for (Edge edge : edgeSet) {
            edges[i][0] = edge.v1;
            edges[i][1] = edge.v2;
            i++;
        }

        return edges;
    }

    /**
     * Helper class to represent an edge and handle equality checks.
     */
    private record Edge(int[] v1, int[] v2) {
        private Edge(int[] v1, int[] v2) {
            // Ensure consistent ordering of vertices for equality comparison
            if (compareVertices(v1, v2) < 0) {
                this.v1 = v1;
                this.v2 = v2;
            } else {
                this.v1 = v2;
                this.v2 = v1;
            }
        }

        @Override
        public boolean equals(Object obj) {
            if (this == obj) return true;
            if (obj == null || getClass() != obj.getClass()) return false;
            Edge other = (Edge) obj;
            return Arrays.equals(v1, other.v1) && Arrays.equals(v2, other.v2);
        }

        @Override
        public int hashCode() {
            return Arrays.hashCode(v1) * 31 + Arrays.hashCode(v2);
        }

        /**
         * Compares two vertices lexicographically.
         */
        private static int compareVertices(int[] a, int[] b) {
            if (a[0] != b[0]) return Integer.compare(a[0], b[0]);
            if (a[1] != b[1]) return Integer.compare(a[1], b[1]);
            return Integer.compare(a[2], b[2]);
        }
    }

    /**
     * Checks if a point lies on an edge between two points.
     *
     * @param point The point to check
     * @param v1 First vertex of the edge
     * @param v2 Second vertex of the edge
     * @return true if the point is on the edge, false otherwise
     */
    private boolean isPointOnEdge(Vector3dc point, Vector3dc v1, Vector3dc v2) {
        // Calculate the vector from v1 to point
        Vector3d v1ToPoint = new Vector3d(point).sub(v1);

        // Calculate the vector from v1 to v2
        Vector3d edge = new Vector3d(v2).sub(v1);

        // If point is not colinear with the edge, it's not on the edge
        Vector3d cross = new Vector3d();
        v1ToPoint.cross(edge, cross);
        if (cross.lengthSquared() > EPSILON * EPSILON) {
            return false;
        }

        // Calculate the parameter t where point = v1 + t * edge
        double t = v1ToPoint.dot(edge) / edge.lengthSquared();

        // Check if t is between 0 and 1 (inclusive with epsilon tolerance)
        return t >= -EPSILON && t <= 1.0 + EPSILON;
    }

    @Override
    public Set<Vector3ic> getBoundaryPoints() {
        Set<Vector3ic> points = new HashSet<>();
        if (edges == null) calculateEncompassingArea();
        if (edges != null) {
            for (int[][] edge : edges) {
                Vector3ic a = new Vector3i(edge[0][0], edge[0][1], edge[0][2]);
                Vector3ic b = new Vector3i(edge[1][0], edge[1][1], edge[1][2]);
                points.addAll(getLinePoints(a, b));
            }
        }
        return points;
    }

    private Set<Vector3i> getLinePoints(Vector3ic start, Vector3ic end) {
        Set<Vector3i> points = new HashSet<>();
        int x1 = start.x(), y1 = start.y(), z1 = start.z();
        int x2 = end.x(), y2 = end.y(), z2 = end.z();
        int dx = Math.abs(x2 - x1), dy = Math.abs(y2 - y1), dz = Math.abs(z2 - z1);
        int xs = x2 > x1 ? 1 : -1, ys = y2 > y1 ? 1 : -1, zs = z2 > z1 ? 1 : -1;
        int n = Math.max(Math.max(dx, dy), dz);
        for (int i = 0; i <= n; i++) {
            int x = x1 + i * (x2 - x1) / n;
            int y = y1 + i * (y2 - y1) / n;
            int z = z1 + i * (z2 - z1) / n;
            points.add(new Vector3i(x, y, z));
        }
        return points;
    }

    @Override
    public int getMinimumPoints() {
        return 4;
    }

    @Override
    public AreaType<?> getType() {
        return AreaType.POLYHEDRAL;
    }
}
