/*
 * This file is part of Orbis, licensed under the MIT License.
 *
 * Copyright (C) 2024 Empire War
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
package org.empirewar.orbis.area;

import com.mojang.serialization.MapCodec;
import com.mojang.serialization.codecs.RecordCodecBuilder;

import org.empirewar.orbis.util.ExtraCodecs;
import org.empirewar.orbis.util.QuickHull3D;
import org.joml.Vector3d;
import org.joml.Vector3dc;
import org.joml.Vector3i;
import org.joml.Vector3ic;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Set;

/**
 * Generated by AI, as I can't find any examples of polyhedral point testing, only 2D point in polygon stuff.
 */
public final class PolyhedralArea extends PolygonArea {

    public static MapCodec<PolyhedralArea> CODEC =
            RecordCodecBuilder.mapCodec(instance -> instance.group(ExtraCodecs.VEC_3I
                            .listOf()
                            .fieldOf("points")
                            .forGetter(c -> new LinkedList<>(c.points)))
                    .apply(instance, PolyhedralArea::new));

    private static final double EPSILON = 1e-7;

    public record Vertex(int x, int y, int z) {
        public Vertex(Vector3ic v) {
            this(v.x(), v.y(), v.z());
        }

        public Vector3i toVector3i() {
            return new Vector3i(x, y, z);
        }
    }

    public record Edge(Vertex v1, Vertex v2) {}

    public record Face(List<Vertex> vertices) {}

    private List<Edge> edges;
    private List<Face> faces;

    public PolyhedralArea() {
        super();
    }

    private PolyhedralArea(List<Vector3ic> points) {
        super(points);
    }

    @Override
    protected void calculateEncompassingArea() {
        super.calculateEncompassingArea();
        try {
            this.faces = getPolyhedronFaces();
            this.edges = getPolyhedronEdges(faces);
            this.boundaryPoints.clear();
            if (points.size() >= getMinimumPoints()) {
                this.boundaryPoints.addAll(generateBoundaryPoints());
            }
        } catch (IllegalArgumentException ignored) {
            // Means there were not enough points
        }
    }

    @Override
    public boolean contains(double x, double y, double z) {
        // Quick bounding box check first with a small epsilon for floating point errors
        if (x < min.x() - EPSILON
                || x > max.x() + EPSILON
                || y < min.y() - EPSILON
                || y > max.y() + EPSILON
                || z < min.z() - EPSILON
                || z > max.z() + EPSILON) {
            return false;
        }

        Vector3dc point = new Vector3d(x, y, z);

        // Check if point is exactly on a vertex
        for (Vector3ic vertex : points) {
            double dist = point.distanceSquared(vertex.x(), vertex.y(), vertex.z());
            if (dist < EPSILON * EPSILON) {
                return true; // Point is on a vertex
            }
        }

        // Check if point is on any edge
        for (Edge edge : edges) {
            Vector3dc v1 = new Vector3d(edge.v1().x, edge.v1().y, edge.v1().z);
            Vector3dc v2 = new Vector3d(edge.v2().x, edge.v2().y, edge.v2().z);
            if (isPointOnEdge(point, v1, v2)) {
                return true; // Point is on an edge
            }
        }

        // Use ray casting algorithm for point-in-polyhedron test
        // Cast a ray in a direction that's unlikely to be parallel to any face
        Vector3dc rayDir = new Vector3d(1, 0.5, 0.3).normalize();
        int intersections = 0;
        for (Face face : faces) {
            // Convert face vertices to Vector3d
            List<Vertex> verts = face.vertices();
            Vector3d[] vertices =
                    verts.stream().map(v -> new Vector3d(v.x, v.y, v.z)).toArray(Vector3d[]::new);

            // Check if point is on the face's plane
            if (isPointOnFace(point, vertices)) {
                return true; // Point is on the face
            }

            // Check intersection with the face (as triangles)
            int faceIntersections = 0;
            for (int i = 1; i < vertices.length - 1; i++) {
                if (rayIntersectsTriangle(
                        point, rayDir, vertices[0], vertices[i], vertices[i + 1])) {
                    faceIntersections++;
                }
            }
            intersections += faceIntersections;
        }
        boolean isInside = (intersections % 2) == 1;
        return isInside;
    }

    /**
     * Returns the faces of the polyhedron by computing the convex hull of the points.
     * Each face is defined by its vertices in counter-clockwise order when viewed from outside.
     *
     * @return list of faces, where each face is an array of 3D points
     */
    private List<Face> getPolyhedronFaces() {
        if (points.size() < 4) {
            // Not enough points to form a 3D polyhedron
            return List.of();
        }
        double[] coords = new double[points.size() * 3];
        int i = 0;
        for (Vector3ic point : points) {
            coords[i++] = point.x();
            coords[i++] = point.y();
            coords[i++] = point.z();
        }

        // Compute convex hull
        QuickHull3D hull = new QuickHull3D();
        hull.build(coords);

        // Get faces from convex hull
        int[][] faceIndices = hull.getFaces();

        // Convert face indices to actual points
        final LinkedList<Vector3ic> pointsList = new LinkedList<>(points);
        List<Face> faces = new ArrayList<>();
        for (int[] face : faceIndices) {
            List<Vertex> verts = new ArrayList<>();
            for (int v : face) {
                Vector3ic p = pointsList.get(v);
                verts.add(new Vertex(p));
            }
            faces.add(new Face(verts));
        }
        return faces;
    }

    private List<Edge> getPolyhedronEdges(List<Face> faces) {
        Set<String> edgeSet = new HashSet<>();
        List<Edge> edges = new java.util.ArrayList<>();
        for (Face face : faces) {
            List<Vertex> verts = face.vertices();
            for (int i = 0; i < verts.size(); i++) {
                Vertex v1 = verts.get(i);
                Vertex v2 = verts.get((i + 1) % verts.size());
                String key =
                        v1.toString().compareTo(v2.toString()) < 0 ? v1 + "-" + v2 : v2 + "-" + v1;
                if (edgeSet.add(key)) {
                    edges.add(new Edge(v1, v2));
                }
            }
        }
        return edges;
    }

    /**
     * Tests if a ray intersects a triangle using the Möller–Trumbore algorithm.
     *
     * @param rayOrigin The origin of the ray
     * @param rayDir The direction of the ray (must be normalized)
     * @param v0 First vertex of the triangle
     * @param v1 Second vertex of the triangle
     * @param v2 Third vertex of the triangle
     * @return true if the ray intersects the triangle, false otherwise
     */
    private boolean rayIntersectsTriangle(
            Vector3dc rayOrigin, Vector3dc rayDir, Vector3dc v0, Vector3dc v1, Vector3dc v2) {
        // Edge vectors
        Vector3d edge1 = new Vector3d();
        Vector3d edge2 = new Vector3d();

        // Calculate edge vectors
        v1.sub(v0, edge1);
        v2.sub(v0, edge2);

        // Calculate determinant
        Vector3d pvec = new Vector3d();
        rayDir.cross(edge2, pvec);
        double det = edge1.dot(pvec);

        // If determinant is near zero, ray is parallel to triangle plane
        if (Math.abs(det) < EPSILON) {
            return false;
        }

        double invDet = 1.0 / det;

        // Calculate distance from v0 to ray origin
        Vector3d tvec = new Vector3d(rayOrigin).sub(v0);

        // Calculate u parameter and test bounds
        double u = tvec.dot(pvec) * invDet;
        if (u < -EPSILON || u > 1.0 + EPSILON) {
            return false;
        }

        // Calculate v parameter and test bounds
        Vector3d qvec = new Vector3d();
        tvec.cross(edge1, qvec);
        double v = rayDir.dot(qvec) * invDet;
        if (v < -EPSILON || (u + v) > 1.0 + EPSILON) {
            return false;
        }

        // Calculate t, ray intersects triangle
        double t = edge2.dot(qvec) * invDet;

        // Check if the intersection is in front of the ray origin
        // We don't need an upper bound since we're checking for ray intersection, not line segment
        // intersection
        return t >= -EPSILON;
    }

    /**
     * Checks if a point lies on a face of the polyhedron.
     *
     * @param point The point to check
     * @param faceVertices The vertices of the face
     * @return true if the point is on the face, false otherwise
     */
    private boolean isPointOnFace(Vector3dc point, Vector3dc[] faceVertices) {
        if (faceVertices.length < 3) {
            return false;
        }

        // Calculate the face normal
        Vector3d v1 = new Vector3d(faceVertices[1]).sub(faceVertices[0]);
        Vector3d v2 = new Vector3d(faceVertices[2]).sub(faceVertices[0]);
        Vector3d normal = new Vector3d();
        v1.cross(v2, normal);

        // Check if point is on the plane of the face
        Vector3d p0 = new Vector3d(faceVertices[0]);
        Vector3d p = new Vector3d(point);
        p.sub(p0);
        double dist = Math.abs(p.dot(normal));

        if (dist > EPSILON) {
            return false; // Point is not on the plane
        }

        // Check if point is inside the face using ray casting in 2D
        // Project the face and point onto the most significant plane
        int coord1, coord2;
        double max = Math.max(Math.abs(normal.x), Math.max(Math.abs(normal.y), Math.abs(normal.z)));

        if (Math.abs(normal.x) == max) {
            coord1 = 1; // y
            coord2 = 2; // z
        } else if (Math.abs(normal.y) == max) {
            coord1 = 0; // x
            coord2 = 2; // z
        } else {
            coord1 = 0; // x
            coord2 = 1; // y
        }

        // Count intersections
        int n = faceVertices.length;
        boolean inside = false;

        for (int i = 0, j = n - 1; i < n; j = i++) {
            double[] vj = {faceVertices[j].x(), faceVertices[j].y(), faceVertices[j].z()};
            double[] vi = {faceVertices[i].x(), faceVertices[i].y(), faceVertices[i].z()};

            double x1 = vj[coord1];
            double y1 = vj[coord2];
            double x2 = vi[coord1];
            double y2 = vi[coord2];

            double px = point.get(coord1);
            double py = point.get(coord2);

            // Check if point is on the edge
            if (isPointOnEdge(px, py, x1, y1, x2, y2)) {
                return true;
            }

            // Check for intersection with the edge
            if (((y1 > py) != (y2 > py)) && (px < (x2 - x1) * (py - y1) / (y2 - y1) + x1)) {
                inside = !inside;
            }
        }

        return inside;
    }

    /**
     * Checks if a point is on an edge between two points.
     */
    private boolean isPointOnEdge(
            double px, double py, double x1, double y1, double x2, double y2) {
        // If the point is not within the bounding box of the edge, it's not on the edge
        if (px < Math.min(x1, x2) - EPSILON
                || px > Math.max(x1, x2) + EPSILON
                || py < Math.min(y1, y2) - EPSILON
                || py > Math.max(y1, y2) + EPSILON) {
            return false;
        }

        // Check if the point is on the line defined by the edge
        double cross = (y2 - y1) * (px - x1) - (x2 - x1) * (py - y1);
        return Math.abs(cross) < EPSILON;
    }

    /**
     * Checks if a point lies on an edge between two points.
     *
     * @param point The point to check
     * @param v1 First vertex of the edge
     * @param v2 Second vertex of the edge
     * @return true if the point is on the edge, false otherwise
     */
    private boolean isPointOnEdge(Vector3dc point, Vector3dc v1, Vector3dc v2) {
        // Calculate the vector from v1 to point
        Vector3d v1ToPoint = new Vector3d(point).sub(v1);

        // Calculate the vector from v1 to v2
        Vector3d edge = new Vector3d(v2).sub(v1);

        // If point is not colinear with the edge, it's not on the edge
        Vector3d cross = new Vector3d();
        v1ToPoint.cross(edge, cross);
        if (cross.lengthSquared() > EPSILON * EPSILON) {
            return false;
        }

        // Calculate the parameter t where point = v1 + t * edge
        double t = v1ToPoint.dot(edge) / edge.lengthSquared();

        // Check if t is between 0 and 1 (inclusive with epsilon tolerance)
        return t >= -EPSILON && t <= 1.0 + EPSILON;
    }

    @Override
    public Set<Vector3ic> getBoundaryPoints() {
        Set<Vector3ic> points = new HashSet<>();
        if (edges == null) calculateEncompassingArea();
        if (edges != null) {
            for (Edge edge : edges) {
                Vector3ic a = edge.v1().toVector3i();
                Vector3ic b = edge.v2().toVector3i();
                points.addAll(getLinePoints(a, b));
            }
        }
        return points;
    }

    private Set<Vector3i> getLinePoints(Vector3ic start, Vector3ic end) {
        Set<Vector3i> points = new HashSet<>();
        int x1 = start.x(), y1 = start.y(), z1 = start.z();
        int x2 = end.x(), y2 = end.y(), z2 = end.z();
        int dx = Math.abs(x2 - x1), dy = Math.abs(y2 - y1), dz = Math.abs(z2 - z1);
        int xs = x2 > x1 ? 1 : -1, ys = y2 > y1 ? 1 : -1, zs = z2 > z1 ? 1 : -1;
        int n = Math.max(Math.max(dx, dy), dz);
        for (int i = 0; i <= n; i++) {
            int x = x1 + i * (x2 - x1) / n;
            int y = y1 + i * (y2 - y1) / n;
            int z = z1 + i * (z2 - z1) / n;
            points.add(new Vector3i(x, y, z));
        }
        return points;
    }

    @Override
    public int getMinimumPoints() {
        return 4;
    }

    @Override
    public AreaType<?> getType() {
        return AreaType.POLYHEDRAL;
    }
}
