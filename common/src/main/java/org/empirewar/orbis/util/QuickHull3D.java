/*
 * This file is part of Orbis, licensed under the MIT License.
 *
 * Copyright (C) 2024 Empire War
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
package org.empirewar.orbis.util;

import java.util.*;

/**
 * A 3D convex hull implementation using the incremental algorithm.
 * This implementation computes the convex hull of a set of 3D points.
 * <p>
 * Generated by AI, as I can't find any examples of polyhedral point testing, only 2D point in polygon stuff.
 */
public final class QuickHull3D {

    private static final double EPSILON = 1e-7;

    // Represents a 3D point with coordinates and index
    private record Point(double x, double y, double z, int index) {

        Point sub(Point p) {
            return new Point(x - p.x, y - p.y, z - p.z, -1);
        }

        Point cross(Point p) {
            return new Point(y * p.z - z * p.y, z * p.x - x * p.z, x * p.y - y * p.x, -1);
        }

        double dot(Point p) {
            return x * p.x + y * p.y + z * p.z;
        }

        double distance(Point p) {
            double dx = x - p.x;
            double dy = y - p.y;
            double dz = z - p.z;
            return Math.sqrt(dx * dx + dy * dy + dz * dz);
        }
    }

    // Represents a face of the convex hull
    private static class Face {
        final int a, b, c; // Vertex indices
        final Point normal; // Face normal (not necessarily unit length)
        boolean visible = true;

        Face(int a, int b, int c, Point normal) {
            this.a = a;
            this.b = b;
            this.c = c;
            this.normal = normal;
        }

        // Check if a point is on the positive side of this face
        boolean isPointOnPositiveSide(Point p, List<Point> points) {
            Point pa = points.get(a);
            Point pb = points.get(b);
            Point pc = points.get(c);

            // Calculate face normal
            Point v1 = pb.sub(pa);
            Point v2 = pc.sub(pa);
            Point n = v1.cross(v2);

            // Vector from face to point
            Point vp = p.sub(pa);

            // Calculate signed distance from point to face plane
            double dist = vp.dot(n);

            // Consider point on positive side if it's outside or exactly on the face
            return dist >= -EPSILON;
        }
    }

    private List<Face> faces;
    private List<Point> points;

    public QuickHull3D() {}

    public void build(double[] coords) {
        build(coords, coords.length / 3);
    }

    public void build(double[] coords, int numPoints) {
        if (numPoints < 4) {
            throw new IllegalArgumentException("Need at least 4 points for 3D convex hull");
        }

        // Initialize points
        points = new ArrayList<>();
        for (int i = 0; i < numPoints; i++) {
            points.add(new Point(coords[i * 3], coords[i * 3 + 1], coords[i * 3 + 2], i));
        }

        // Remove duplicate points
        removeDuplicatePoints();

        if (points.size() < 4) {
            throw new IllegalArgumentException("Not enough unique points to form a 3D convex hull");
        }

        // Compute convex hull
        computeConvexHull();
    }

    private void removeDuplicatePoints() {
        List<Point> uniquePoints = new ArrayList<>();
        Set<String> seen = new HashSet<>();

        for (Point p : points) {
            String key = String.format("%.6f,%.6f,%.6f", p.x, p.y, p.z);
            if (!seen.contains(key)) {
                seen.add(key);
                uniquePoints.add(p);
            }
        }

        points = uniquePoints;
    }

    private void computeConvexHull() {
        // Find initial tetrahedron
        if (!findInitialTetrahedron()) {
            throw new IllegalArgumentException("Input points appear to be co-linear or co-planar");
        }

        // Process remaining points
        for (int i = 4; i < points.size(); i++) {
            processPoint(i);
        }
    }

    private boolean findInitialTetrahedron() {
        // Find 4 non-coplanar points to form a tetrahedron
        if (points.size() < 4) {
            return false;
        }

        // Use first 4 points as initial tetrahedron
        Point p0 = points.get(0);
        Point p1 = points.get(1);
        Point p2 = points.get(2);
        Point p3 = points.get(3);

        // Check if points are coplanar
        Point v1 = p1.sub(p0);
        Point v2 = p2.sub(p0);
        Point v3 = p3.sub(p0);

        double volume = v1.x * (v2.y * v3.z - v2.z * v3.y)
                - v1.y * (v2.x * v3.z - v2.z * v3.x)
                + v1.z * (v2.x * v3.y - v2.y * v3.x);

        if (Math.abs(volume) < EPSILON) {
            // Points are coplanar, try to find a different set
            for (int i = 4; i < points.size(); i++) {
                p3 = points.get(i);
                v3 = p3.sub(p0);
                volume = v1.x * (v2.y * v3.z - v2.z * v3.y)
                        - v1.y * (v2.x * v3.z - v2.z * v3.x)
                        + v1.z * (v2.x * v3.y - v2.y * v3.x);

                if (Math.abs(volume) > EPSILON) {
                    // Found non-coplanar point
                    Collections.swap(points, 3, i);
                    break;
                }
            }

            if (Math.abs(volume) < EPSILON) {
                return false; // All points are coplanar
            }
        }

        // Create faces of the tetrahedron with consistent orientation
        faces = new ArrayList<>();

        // Face 0: p0, p1, p2 (counter-clockwise when viewed from outside)
        Point n1 = v1.cross(v2);
        if (n1.dot(p3.sub(p0)) > 0) {
            faces.add(new Face(0, 1, 2, n1));
        } else {
            faces.add(new Face(0, 2, 1, new Point(-n1.x, -n1.y, -n1.z, -1)));
        }

        // Face 1: p0, p2, p3
        Point n2 = v2.cross(v3);
        if (n2.dot(p1.sub(p0)) > 0) {
            faces.add(new Face(0, 2, 3, n2));
        } else {
            faces.add(new Face(0, 3, 2, new Point(-n2.x, -n2.y, -n2.z, -1)));
        }

        // Face 2: p0, p3, p1
        Point n3 = v3.cross(v1);
        if (n3.dot(p2.sub(p0)) > 0) {
            faces.add(new Face(0, 3, 1, n3));
        } else {
            faces.add(new Face(0, 1, 3, new Point(-n3.x, -n3.y, -n3.z, -1)));
        }

        // Face 3: p1, p3, p2
        Point n4 = (p3.sub(p1)).cross(p2.sub(p1));
        if (n4.dot(p0.sub(p1)) > 0) {
            faces.add(new Face(1, 3, 2, n4));
        } else {
            faces.add(new Face(1, 2, 3, new Point(-n4.x, -n4.y, -n4.z, -1)));
        }

        return true;
    }

    private void processPoint(int pointIndex) {
        Point p = points.get(pointIndex);
        List<Face> visibleFaces = new ArrayList<>();

        // Find all visible faces
        for (Face face : faces) {
            if (face.visible && face.isPointOnPositiveSide(p, points)) {
                face.visible = false;
                visibleFaces.add(face);
            }
        }

        if (visibleFaces.isEmpty()) {
            return; // Point is inside the convex hull
        }

        // Find all edges between visible faces
        Set<String> horizonEdges = new HashSet<>();
        for (Face face : visibleFaces) {
            addHorizonEdges(face, horizonEdges, visibleFaces);
        }

        // Remove visible faces
        faces.removeAll(visibleFaces);

        // Create new faces with the point and horizon edges
        for (String edge : horizonEdges) {
            String[] indices = edge.split(",");
            int a = Integer.parseInt(indices[0]);
            int b = Integer.parseInt(indices[1]);

            // Create new face with point and edge a-b
            Point pa = points.get(a);
            Point pb = points.get(b);
            Point normal = pb.sub(pa).cross(p.sub(pa));
            faces.add(new Face(a, b, pointIndex, normal));
        }
    }

    private void addHorizonEdges(Face face, Set<String> horizonEdges, List<Face> visibleFaces) {
        int[][] edges = {
            {face.a, face.b},
            {face.b, face.c},
            {face.c, face.a}
        };

        for (int[] edge : edges) {
            String edgeKey = edge[0] + "," + edge[1];
            String reverseKey = edge[1] + "," + edge[0];

            if (horizonEdges.contains(reverseKey)) {
                horizonEdges.remove(reverseKey);
            } else {
                horizonEdges.add(edgeKey);
            }
        }
    }

    public int[][] getFaces() {
        if (faces == null) {
            return new int[0][];
        }

        // Only include visible faces in the result
        List<int[]> result = new ArrayList<>();
        for (Face face : faces) {
            if (face.visible) {
                result.add(new int[] {face.a, face.b, face.c});
            }
        }

        return result.toArray(new int[0][]);
    }
}
